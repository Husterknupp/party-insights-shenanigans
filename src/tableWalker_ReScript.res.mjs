// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Exn from "rescript/lib/es6/Exn.js";
import * as Cheerio from "cheerio";
import * as Core__Int from "@rescript/core/src/Core__Int.res.mjs";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Error from "@rescript/core/src/Core__Error.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as Core__Nullable from "@rescript/core/src/Core__Nullable.res.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";

let applyElementToCheerioUnsafe = (function(element, selectorFunction) {
        return selectorFunction(element)
      });

function load(html, maybeOptions, isDocument) {
  let loadedCheerio = Cheerio.load(html, maybeOptions, isDocument);
  return (unsafeFromJsLand, basicAcceptedElems) => {
    if (unsafeFromJsLand !== undefined) {
      return applyElementToCheerioUnsafe(Primitive_option.valFromOption(unsafeFromJsLand), loadedCheerio);
    } else {
      return applyElementToCheerioUnsafe(basicAcceptedElems._0, loadedCheerio);
    }
  };
}

function cheerioToElementArray(queriedCheerio) {
  return queriedCheerio.toArray();
}

function getParent(element) {
  return element.parent;
}

function getParentExn(element) {
  return Belt_Option.getExn(element.parent);
}

function getChildren(element) {
  return element.children;
}

function getType(element) {
  return element.type;
}

function getData(element) {
  if (element.type !== "text" && element.type !== "comment" && element.type !== "directive") {
    Exn.raiseError("Trying to get 'data' from non-text element");
  }
  return element.data;
}

function getName(element) {
  return element.name;
}

function getColspan(element) {
  let match = element.type;
  if (match !== "style" && match !== "tag" && match !== "script") {
    return Exn.raiseError("Trying to get 'colspan' from non-element node");
  }
  let colspan = Core__Nullable.getExn(element.attribs).colspan;
  if (colspan == null) {
    return "1";
  } else {
    return colspan;
  }
}

function getColspanInt(element) {
  let parsed = Core__Int.fromString(getColspan(element), undefined);
  if (parsed !== undefined) {
    return parsed;
  } else {
    return 1;
  }
}

function getRowspan(element) {
  let match = element.type;
  if (match !== "style" && match !== "tag" && match !== "script") {
    return Exn.raiseError("Trying to get 'rowspan' from non-element node");
  }
  let rowspan = Core__Nullable.getExn(element.attribs).rowspan;
  if (rowspan == null) {
    return "1";
  } else {
    return rowspan;
  }
}

function getRowspanInt(element) {
  let parsed = Core__Int.fromString(getRowspan(element), undefined);
  if (parsed !== undefined) {
    return parsed;
  } else {
    return 1;
  }
}

function getText(element, loadedCheerio) {
  return loadedCheerio(undefined, {
    TAG: "CheerioElement",
    _0: element
  }).text();
}

function getLengthString(queriedCheerio) {
  return queriedCheerio.length.toString();
}

function each(queriedCheerio, callback) {
  queriedCheerio.each(callback);
}

function find(queriedCheerio, queryString) {
  return queriedCheerio.find(queryString);
}

function remove(queriedCheerio) {
  return queriedCheerio.remove();
}

function contents(queriedCheerio) {
  return queriedCheerio.contents();
}

function getLast(queriedCheerio) {
  return queriedCheerio.last();
}

function getSrc(element) {
  return Primitive_option.fromNullable(element.attr("src"));
}

let CheerioFacade = {
  applyElementToCheerioUnsafe: applyElementToCheerioUnsafe,
  load: load,
  cheerioToElementArray: cheerioToElementArray,
  getParent: getParent,
  getParentExn: getParentExn,
  getChildren: getChildren,
  getType: getType,
  getData: getData,
  getName: getName,
  getColspan: getColspan,
  getColspanInt: getColspanInt,
  getRowspan: getRowspan,
  getRowspanInt: getRowspanInt,
  getText: getText,
  getLengthString: getLengthString,
  each: each,
  find: find,
  remove: remove,
  contents: contents,
  getLast: getLast,
  getSrc: getSrc
};

function _loadCheerio(html) {
  if (html.indexOf("<html>") !== -1) {
    return load(html, null, true);
  } else {
    return load(html, null, false);
  }
}

function _sanityCheckHeaders(cheerioWithHeaders) {
  let headerElements = cheerioWithHeaders.toArray();
  let firstHeader = Core__Option.getExn(headerElements[0], undefined);
  if (firstHeader.name !== "th") {
    console.log(firstHeader);
    Core__Error.panic("Queried cheerio was expected to contain any headers. But it doesn't");
  }
  let parent = Belt_Option.getExn(firstHeader.parent);
  let maybeInvalidHeader = headerElements.find(header => Belt_Option.getExn(header.parent) !== parent);
  if (maybeInvalidHeader === undefined) {
    return;
  }
  let invalidHeader = Primitive_option.valFromOption(maybeInvalidHeader);
  let thText = invalidHeader.children.map(getData).toString();
  let expected = parent.name;
  let actual = Core__Option.getExn(invalidHeader.parent, undefined).name;
  Core__Error.panic("Multiple headline rows--that's bad. <th>" + thText + "</th>. Expected parent element " + expected + ", but was " + actual);
}

function parseIntOr(maybeString, fallback) {
  let n = Core__Int.fromString(maybeString, undefined);
  if (n !== undefined) {
    return n;
  } else {
    return fallback;
  }
}

function removeInnerWhiteSpace(text) {
  return text.replace(/\s+/g, " ").trim();
}

function _getHeaderCells(loadedCheerio) {
  let ths = loadedCheerio(undefined, {
    TAG: "String",
    _0: "th"
  });
  _sanityCheckHeaders(ths);
  let thElements = ths.toArray();
  let columnCount = Core__Array.reduce(thElements.map(getColspanInt), 0, (prev, curr) => prev + curr | 0);
  console.log("Found " + thElements.length.toString() + " table headers (spanning " + columnCount.toString() + " columns).");
  return Core__Array.reduceWithIndex(thElements, [], (headers, header, headerIdx) => {
    let maybePreviousCol = Core__Option.map(headers[headerIdx - 1 | 0], h => h.colEnd);
    let colStart = maybePreviousCol !== undefined ? maybePreviousCol + 1 | 0 : 0;
    let colEnd = (colStart + getColspanInt(header) | 0) - 1 | 0;
    let linesOfText = [removeInnerWhiteSpace(getText(header, loadedCheerio))];
    return headers.concat([{
        colStart: colStart,
        colEnd: colEnd,
        linesOfText: linesOfText
      }]);
  });
}

function getStartIndexForCell(allCells, initialColumnIdx, rowIndex) {
  let _columnIdx = initialColumnIdx;
  while (true) {
    let columnIdx = _columnIdx;
    let maybeShiftCellRight = allCells.find(cell => {
      if (cell.colStart <= columnIdx && columnIdx <= cell.colEnd) {
        return cell.rowEnd >= rowIndex;
      } else {
        return false;
      }
    });
    if (maybeShiftCellRight === undefined) {
      return columnIdx;
    }
    console.log("Row no. " + rowIndex.toString() + ": At column " + columnIdx.toString() + " I found a cell of an earlier row... one to the right");
    _columnIdx = maybeShiftCellRight.colEnd + 1 | 0;
    continue;
  };
}

function _getDataCells(cheerio) {
  let rows = cheerio(undefined, {
    TAG: "String",
    _0: "tr:has(td)"
  });
  console.log("Found " + rows.length.toString() + " rows (not including rowspans).");
  let allCells = [];
  rows.each((rowIndex, row) => {
    let queriedCheerio = cheerio(undefined, {
      TAG: "CheerioElement",
      _0: row
    });
    let dataCells = queriedCheerio.find("td");
    let columnIdx = {
      contents: 0
    };
    dataCells.each((param, cell) => {
      let colStart = getStartIndexForCell(allCells, columnIdx.contents, rowIndex);
      let colEnd = (colStart + getColspanInt(cell) | 0) - 1 | 0;
      let rowEnd = (rowIndex + getRowspanInt(cell) | 0) - 1 | 0;
      allCells.push({
        colStart: colStart,
        colEnd: colEnd,
        rowStart: rowIndex,
        rowEnd: rowEnd,
        _cheerioEl: Primitive_option.some(cell)
      });
      columnIdx.contents = colEnd + 1 | 0;
    });
  });
  return allCells;
}

function concatenate(a, b) {
  let isPunctuation = c => {
    if (c === "." || c === "," || c === "?" || c === "!" || c === ":") {
      return true;
    } else {
      return c === ";";
    }
  };
  let firstChar = b.charAt(0);
  if (firstChar === "") {
    return a;
  } else if (isPunctuation(firstChar)) {
    return a + b;
  } else {
    return a + " " + b;
  }
}

function removeInvisibleSourceLineBreaks(cheerio, node) {
  let lines = [];
  let queriedCheerio = cheerio(undefined, {
    TAG: "CheerioElement",
    _0: node
  });
  let queriedCheerio$1 = queriedCheerio.contents();
  let nodes = queriedCheerio$1.toArray();
  let currentInlineText = {
    contents: ""
  };
  let flushInlineText = () => {
    if (currentInlineText.contents !== "") {
      lines.push(removeInnerWhiteSpace(currentInlineText.contents));
      currentInlineText.contents = "";
      return;
    }
    
  };
  nodes.forEach(node => {
    let text = getText(node, cheerio).trim();
    let nodeName = node.name;
    if (nodeName === "p" || nodeName === "br") {
      flushInlineText();
      if (nodeName === "p" && text !== "") {
        lines.push(removeInnerWhiteSpace(text));
        return;
      } else {
        return;
      }
    } else if (text !== "") {
      currentInlineText.contents = concatenate(currentInlineText.contents, text);
      return;
    } else {
      return;
    }
  });
  flushInlineText();
  return lines;
}

function _extractTextFromCell(cheerio, cell) {
  let queriedCheerio = cheerio(undefined, {
    TAG: "CheerioElement",
    _0: Core__Option.getExn(cell._cheerioEl, undefined)
  });
  let queriedCheerio$1 = queriedCheerio.find("small");
  queriedCheerio$1.remove();
  let queriedCheerio$2 = cheerio(undefined, {
    TAG: "CheerioElement",
    _0: Core__Option.getExn(cell._cheerioEl, undefined)
  });
  let queriedCheerio$3 = queriedCheerio$2.find("sup");
  queriedCheerio$3.remove();
  return removeInvisibleSourceLineBreaks(cheerio, Core__Option.getExn(cell._cheerioEl, undefined));
}

function _extractAndResizeImageUrl(cheerio, cell) {
  let queriedCheerio = cheerio(undefined, {
    TAG: "CheerioElement",
    _0: Core__Option.getExn(cell._cheerioEl, undefined)
  });
  let queriedCheerio$1 = queriedCheerio.find("img");
  let imageElement = queriedCheerio$1.last();
  return Core__Option.map(Primitive_option.fromNullable(imageElement.attr("src")), src => {
    let parts = src.split("/");
    let filtered = parts.filter((param, index) => index !== (parts.length - 1 | 0));
    let lastPart = Core__Option.getExn(filtered[filtered.length - 1 | 0], undefined);
    let newLastPart = "400px-" + lastPart.replace(/\.tif$/, ".png");
    filtered.push(newLastPart);
    return "https:" + filtered.join("/");
  });
}

function _findHeaderTextForCell(headerCells, cell, content) {
  let header = headerCells.find(header => {
    if (header.colStart <= cell.colStart) {
      return cell.colStart <= header.colEnd;
    } else {
      return false;
    }
  });
  if (header !== undefined) {
    return Core__Option.getExn(header.linesOfText[0], undefined);
  } else {
    return Core__Error.panic("Could not find matching header. Cell's content is \"" + content.join("") + "\". Cell is located at col " + cell.colStart.toString() + " (colEnd: " + cell.colEnd.toString() + "), row " + cell.rowStart.toString() + " (rowEnd: " + cell.rowEnd.toString() + ")");
  }
}

function _cellHasContent(cell) {
  if (cell.linesOfText.length !== 0) {
    return true;
  } else {
    return Core__Option.isSome(cell.imageUrl);
  }
}

function tableWalker(html) {
  let cheerio = _loadCheerio(html);
  let headerCells = _getHeaderCells(cheerio);
  let dataCells = _getDataCells(cheerio);
  return dataCells.map(cell => {
    let linesOfText = _extractTextFromCell(cheerio, cell);
    let imageUrl = _extractAndResizeImageUrl(cheerio, cell);
    let header = _findHeaderTextForCell(headerCells, cell, linesOfText);
    return {
      colStart: cell.colStart,
      colEnd: cell.colEnd,
      rowStart: cell.rowStart,
      rowEnd: cell.rowEnd,
      imageUrl: imageUrl,
      header: header,
      linesOfText: linesOfText
    };
  }).filter(_cellHasContent);
}

export {
  CheerioFacade,
  _loadCheerio,
  _sanityCheckHeaders,
  parseIntOr,
  removeInnerWhiteSpace,
  _getHeaderCells,
  getStartIndexForCell,
  _getDataCells,
  concatenate,
  removeInvisibleSourceLineBreaks,
  _extractTextFromCell,
  _extractAndResizeImageUrl,
  _findHeaderTextForCell,
  _cellHasContent,
  tableWalker,
}
/* cheerio Not a pure module */
