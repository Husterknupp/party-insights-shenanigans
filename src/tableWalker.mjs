// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Array from "@rescript/core/src/Core__Array.mjs";
import * as Core__Error from "@rescript/core/src/Core__Error.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.mjs";
import * as CheerioFacade from "./cheerioFacade.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";

function loadCheerio(html) {
  if (html.indexOf("<html>") !== -1) {
    return CheerioFacade.load(html, null, true);
  } else {
    return CheerioFacade.load(html, null, false);
  }
}

function _sanityCheckHeaders(cheerioWithHeaders) {
  let headerElements = CheerioFacade.cheerioToElementArray(cheerioWithHeaders);
  let firstHeader = Core__Option.getExn(headerElements[0], undefined);
  if (CheerioFacade.getName(firstHeader) !== "th") {
    console.log(firstHeader);
    Core__Error.panic("Queried cheerio was expected to contain any headers. But it doesn't");
  }
  let parent = CheerioFacade.getParentExn(firstHeader);
  let maybeInvalidHeader = headerElements.find(header => CheerioFacade.getParentExn(header) !== parent);
  if (maybeInvalidHeader === undefined) {
    return;
  }
  let invalidHeader = Primitive_option.valFromOption(maybeInvalidHeader);
  let thText = CheerioFacade.getChildren(invalidHeader).map(CheerioFacade.getData).toString();
  let expected = CheerioFacade.getName(parent);
  let actual = CheerioFacade.getName(Core__Option.getExn(CheerioFacade.getParent(invalidHeader), undefined));
  Core__Error.panic("Multiple headline rows--that's bad. <th>" + thText + "</th>. Expected parent element " + expected + ", but was " + actual);
}

function _removeInnerWhiteSpace(text) {
  return text.replace(/\s+/g, " ").trim();
}

function _getHeaderCells(loadedCheerio) {
  let ths = loadedCheerio(undefined, {
    TAG: "StringSelector",
    _0: "th"
  });
  _sanityCheckHeaders(ths);
  let thElements = CheerioFacade.cheerioToElementArray(ths);
  let columnCount = Core__Array.reduce(thElements.map(CheerioFacade.getColspanInt), 0, (prev, curr) => prev + curr | 0);
  console.log("Found " + thElements.length.toString() + " table headers (spanning " + columnCount.toString() + " columns).");
  return Core__Array.reduceWithIndex(thElements, [], (headers, header, headerIdx) => {
    let maybePreviousCol = Core__Option.map(headers[headerIdx - 1 | 0], h => h.colEnd);
    let colStart = maybePreviousCol !== undefined ? maybePreviousCol + 1 | 0 : 0;
    let colEnd = (colStart + CheerioFacade.getColspanInt(header) | 0) - 1 | 0;
    let linesOfText = [_removeInnerWhiteSpace(CheerioFacade.getText(header, loadedCheerio))];
    return headers.concat([{
        colStart: colStart,
        colEnd: colEnd,
        linesOfText: linesOfText
      }]);
  });
}

function _getStartIndexForCell(allCells, initialColumnIdx, rowIndex) {
  let _columnIdx = initialColumnIdx;
  while (true) {
    let columnIdx = _columnIdx;
    let maybeShiftCellRight = allCells.find(cell => {
      if (cell.colStart <= columnIdx && columnIdx <= cell.colEnd) {
        return cell.rowEnd >= rowIndex;
      } else {
        return false;
      }
    });
    if (maybeShiftCellRight === undefined) {
      return columnIdx;
    }
    console.log("Row no. " + rowIndex.toString() + ": At column " + columnIdx.toString() + " I found a cell of an earlier row... one to the right");
    _columnIdx = maybeShiftCellRight.colEnd + 1 | 0;
    continue;
  };
}

function _getDataCells(cheerio) {
  let rows = cheerio(undefined, {
    TAG: "StringSelector",
    _0: "tr:has(td)"
  });
  console.log("Found " + CheerioFacade.getLengthString(rows) + " rows (not including rowspans).");
  let allCells = [];
  CheerioFacade.each(rows, (rowIndex, row) => {
    let dataCells = CheerioFacade.find(cheerio(undefined, {
      TAG: "AnyNode",
      _0: row
    }), "td");
    let columnIdx = {
      contents: 0
    };
    CheerioFacade.each(dataCells, (param, cell) => {
      let colStart = _getStartIndexForCell(allCells, columnIdx.contents, rowIndex);
      let colEnd = (colStart + CheerioFacade.getColspanInt(cell) | 0) - 1 | 0;
      let rowEnd = (rowIndex + CheerioFacade.getRowspanInt(cell) | 0) - 1 | 0;
      allCells.push({
        colStart: colStart,
        colEnd: colEnd,
        rowStart: rowIndex,
        rowEnd: rowEnd,
        _cheerioEl: Primitive_option.some(cell)
      });
      columnIdx.contents = colEnd + 1 | 0;
    });
  });
  return allCells;
}

function _concatenate(a, b) {
  let isPunctuation = c => {
    if (c === "." || c === "," || c === "?" || c === "!" || c === ":") {
      return true;
    } else {
      return c === ";";
    }
  };
  let firstChar = b.charAt(0);
  if (firstChar === "") {
    return a;
  } else if (isPunctuation(firstChar)) {
    return a + b;
  } else {
    return a + " " + b;
  }
}

function removeInvisibleSourceLineBreaks(cheerio, node) {
  let lines = [];
  let nodes = CheerioFacade.cheerioToElementArray(CheerioFacade.contents(cheerio(undefined, {
    TAG: "AnyNode",
    _0: node
  })));
  let currentInlineText = {
    contents: ""
  };
  let flushInlineText = () => {
    if (currentInlineText.contents !== "") {
      lines.push(_removeInnerWhiteSpace(currentInlineText.contents));
      currentInlineText.contents = "";
      return;
    }
    
  };
  nodes.forEach(node => {
    let text = CheerioFacade.getText(node, cheerio).trim();
    let nodeName = CheerioFacade.getName(node);
    if (nodeName === "p" || nodeName === "br") {
      flushInlineText();
      if (nodeName === "p" && text !== "") {
        lines.push(_removeInnerWhiteSpace(text));
        return;
      } else {
        return;
      }
    } else if (text !== "") {
      currentInlineText.contents = _concatenate(currentInlineText.contents, text);
      return;
    } else {
      return;
    }
  });
  flushInlineText();
  return lines;
}

function _extractTextFromCell(cheerio, cell) {
  CheerioFacade.remove(CheerioFacade.find(cheerio(undefined, {
    TAG: "AnyNode",
    _0: Core__Option.getExn(cell._cheerioEl, undefined)
  }), "small"));
  CheerioFacade.remove(CheerioFacade.find(cheerio(undefined, {
    TAG: "AnyNode",
    _0: Core__Option.getExn(cell._cheerioEl, undefined)
  }), "sup"));
  return removeInvisibleSourceLineBreaks(cheerio, Core__Option.getExn(cell._cheerioEl, undefined));
}

function _extractAndResizeImageUrl(cheerio, cell) {
  let imageElement = CheerioFacade.getLast(CheerioFacade.find(cheerio(undefined, {
    TAG: "AnyNode",
    _0: Core__Option.getExn(cell._cheerioEl, undefined)
  }), "img"));
  return Core__Option.map(CheerioFacade.getSrc(imageElement), src => {
    let parts = src.split("/");
    let filtered = parts.filter((param, index) => index !== (parts.length - 1 | 0));
    let lastPart = Core__Option.getExn(filtered[filtered.length - 1 | 0], undefined);
    let newLastPart = "400px-" + lastPart.replace(/\.tif$/, ".png");
    filtered.push(newLastPart);
    return "https:" + filtered.join("/");
  });
}

function _findHeaderTextForCell(headerCells, cell, content) {
  let header = headerCells.find(header => {
    if (header.colStart <= cell.colStart) {
      return cell.colStart <= header.colEnd;
    } else {
      return false;
    }
  });
  if (header !== undefined) {
    return Core__Option.getExn(header.linesOfText[0], undefined);
  } else {
    return Core__Error.panic("Could not find matching header. Cell's content is \"" + content.join("") + "\". Cell is located at col " + cell.colStart.toString() + " (colEnd: " + cell.colEnd.toString() + "), row " + cell.rowStart.toString() + " (rowEnd: " + cell.rowEnd.toString() + ")");
  }
}

function _cellHasContent(cell) {
  if (cell.linesOfText.length !== 0) {
    return true;
  } else {
    return Core__Option.isSome(cell.imageUrl);
  }
}

function tableWalker(html) {
  let cheerio = loadCheerio(html);
  let headerCells = _getHeaderCells(cheerio);
  let dataCells = _getDataCells(cheerio);
  return dataCells.map(cell => {
    let linesOfText = _extractTextFromCell(cheerio, cell);
    let imageUrl = _extractAndResizeImageUrl(cheerio, cell);
    let header = _findHeaderTextForCell(headerCells, cell, linesOfText);
    return {
      colStart: cell.colStart,
      colEnd: cell.colEnd,
      rowStart: cell.rowStart,
      rowEnd: cell.rowEnd,
      imageUrl: imageUrl,
      header: header,
      linesOfText: linesOfText
    };
  }).filter(_cellHasContent);
}

export {
  loadCheerio,
  _sanityCheckHeaders,
  _removeInnerWhiteSpace,
  _getHeaderCells,
  _getStartIndexForCell,
  _getDataCells,
  _concatenate,
  removeInvisibleSourceLineBreaks,
  _extractTextFromCell,
  _extractAndResizeImageUrl,
  _findHeaderTextForCell,
  _cellHasContent,
  tableWalker,
}
/* CheerioFacade Not a pure module */
